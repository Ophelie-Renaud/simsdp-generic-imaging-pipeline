/**
 * @file sub.c
 * @generated by CPrinter
 * @date Wed Jan 22 07:44:21 CET 2025
 *
 */
// no monitoring by default
#define _PREESM_NBTHREADS_ 1
#define _PREESM_MAIN_THREAD_ 0

// application dependent includes
#include "../preesm_gen.h"

// Declare computation thread functions
void* computationThread_setup(void *arg);


#ifndef _WIN32
#include <execinfo.h>
#endif
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef _WIN32
void handler(int sig) {
  void *array[30];
  size_t size;
  size = backtrace(array, 30);
  fprintf(stderr, "Error: signal %d:\n", sig);
  backtrace_symbols_fd(array, size, STDERR_FILENO);
  exit(1);
}
#endif
pthread_barrier_t iter_barrier;
int preesmStopThreads;

#ifdef PREESM_MD5_UPDATE
		struct rk_sema preesmPrintSema;
#endif
unsigned int launch(unsigned int core_id, pthread_t *thread, void* (*start_routine)(void*), void* arg) {
  // init pthread attributes
  pthread_attr_t attr;
  pthread_attr_init(&attr);

#ifndef PREESM_NO_AFFINITY
#ifdef _WIN32
			SYSTEM_INFO sysinfo;
			GetSystemInfo(&sysinfo);
			unsigned int numCPU = sysinfo.dwNumberOfProcessors;
		#else
  unsigned int numCPU = sysconf(_SC_NPROCESSORS_ONLN);
#endif

  // check CPU id is valid
  if (core_id >= numCPU) {
    // leave attribute uninitialized
    printf(
        "** Warning: thread %d will not be set with specific core affinity \n   due to the lack of available dedicated cores.\n",
        core_id);
  } else {
#if defined __APPLE__ || defined _WIN32
				// NOT SUPPORTED
		#else
    // init cpuset struct
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core_id, &cpuset);

    // set pthread affinity
    pthread_attr_setaffinity_np(&attr, sizeof(cpuset), &cpuset);
#endif
  }
#endif

  // create thread
  pthread_create(thread, &attr, start_routine, arg);
  return 0;
}

void set_up(int num_vis, int grid_size, int num_minor_cycle, const char* ms_path, const char* out_path, Config config,PRECISION *clean_psf,int2 *psf_halfdims, int2 *gridding_kernel_supports,PRECISION2 *gridding_kernels,PRECISION *psf,int2 *receiver_pairs,PRECISION3 *vis_uvw_coords,int2 *degridding_kernel_supports,PRECISION2 *degridding_kernels,PRECISION2 *gains,PRECISION2 *measured_visibilities,PRECISION *prolate){

  int NUM_VIS = num_vis;
  int GRID_SIZE = grid_size;
  int NUM_MINOR_CYCLE = num_minor_cycle;

  ThreadArgs args;
  args.num_vis = NUM_VIS;
  args.grid_size = GRID_SIZE;
  args.num_minor_cycle = NUM_MINOR_CYCLE;
  args.ms_path = ms_path;
  args.out_path = out_path;
  args.config = config;
  args.clean_psf = clean_psf;
  args.psf_halfdims = psf_halfdims;
  args.gridding_kernel_supports = gridding_kernel_supports;
  args.gridding_kernels = gridding_kernels;
  args.gains = gains;
  args.measured_visibilities = measured_visibilities;
  args.prolate = prolate;
  args.psf = psf;
  args.receiver_pairs = receiver_pairs;
  args.vis_uvw_coords = vis_uvw_coords;
  args.degridding_kernel_supports = degridding_kernel_supports;
  args.degridding_kernels = degridding_kernels;

#ifndef _WIN32
  signal(SIGSEGV, handler);
  signal(SIGPIPE, handler);
#endif
  // Set affinity of main thread to proper core ID
#ifndef PREESM_NO_AFFINITY
#if defined __APPLE__ || defined _WIN32
			// NOT SUPPORTED
		#else
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(_PREESM_MAIN_THREAD_, &cpuset);
  sched_setaffinity(getpid(), sizeof(cpuset), &cpuset);

#endif
#endif

  // Declaring thread pointers
  pthread_t coreThreads[_PREESM_NBTHREADS_];
  void* (*coreThreadComputations[_PREESM_NBTHREADS_])(void*) = {
    &computationThread_setup
  };

#ifdef PREESM_VERBOSE
			printf("Launched main\n");
		#endif
  // Creating a synchronization barrier

  preesmStopThreads = 0;
  pthread_barrier_init(&iter_barrier, NULL, _PREESM_NBTHREADS_);
#ifdef PREESM_MD5_UPDATE
			rk_sema_init(&preesmPrintSema, 1);
#endif
  communicationInit();

  // Creating threads
  for (int i = 0; i < _PREESM_NBTHREADS_; i++) {
    if (i != _PREESM_MAIN_THREAD_) {
      if (launch(i, &coreThreads[i], coreThreadComputations[i],&args)) {
        printf("Error: could not launch thread %d\n", i);
        return ;

      }
    }
  }

  // run main operator code in this thread
  coreThreadComputations[_PREESM_MAIN_THREAD_](&args);

  // Waiting for thread terminations
  for (int i = 0; i < _PREESM_NBTHREADS_; i++) {
    if (i != _PREESM_MAIN_THREAD_) {
      pthread_join(coreThreads[i], NULL);
    }
  }
  return;
}

